<!DOCTYPE html>
<html>
<style>
    #game{
        background: powderblue;
        position: absolute;
        top:50%;
        left:0;
        transform: translateY(-50%);
    } 
    
    #edit{
        position: absolute;
        top:0;
        right:0;
        background: white;
        width:20vw;
        height: calc(100vh - 80px);
        padding: 40px;
        border-left:5px solid #e3e3e3;
    }
    
    #edit p{
        font-family: sans-serif;
        text-align: left;
        font-weight: 100;
        font-size: 3vh;
        letter-spacing: 5px;
        margin: 4% 0;
    }
    

    #height {
        -webkit-appearance: none;
        width: 95%;
        display: block;
        margin: 20% auto;
        height: 15px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        border-radius: 20px;
    }

    #height::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #4CAF50;
        cursor: pointer;
    }
    
    body{
        margin:0;
        padding: 0;
    }
    
    #toolBar{
        position: absolute;
        background: rgba(255, 255, 255, 0.68);
        left: 0;
        bottom:5vh;
        left:40vw;
        transform: translateX(-50%);
        border-radius: 20px;
        padding: 1%;
        width:50vw;
        text-align: center;
    }
    
    #toolBar button{
        height:6vh;
        width:6vh;
        margin-left: 5%;
    }
    
    #toolBar button:first-child{
        margin-left: 0;
    }
    
    #tileContainer{
        width:95%;
        height: 55vh;
        overflow-y: scroll;
        display: block;
        margin: 15% auto 0;
        border: 1px solid black;
    }
    
    #tileContainer button{
        display: block;
        background: white;
        border:none;
        border-bottom: 1px solid black;
        width: 100%;
        height:10%;
        text-align: left;
        padding-left: 10%;
        font-size: 2vh;
    }
    
    #tileContainer button:hover{
        background: lightgray;
    }
    
    #tileContainer a{
        font-family: sans-serif;
        text-decoration: none;
        font-style: italic;
        text-align: center;
        display: block;
        margin-top:5%;
    }
</style>

<canvas id="game"></canvas>
    
<div id="edit">
    <p>Height:</p>
    <hr>
    <input type="range" min="5" max="30" value="10" id="height" step="1" oninput="changeHeight()">
    <p>Type:</p>
    <hr>
    
    <div id="tileContainer">
        <button onclick="switchTile(0)">Empty</button>
        <button onclick="switchTile(1)">Grass</button>
        <button onclick="switchTile(2)">Water</button>
        <button onclick="switchTile(3)">Sand</button>
        <button onclick="switchTile(4)">Stone</button>
        <a href="">+ Create More Tiles +</a>
    </div>
</div>
    
<div id="toolBar">
    <button onclick="canEdit = 0; canvas.style.cursor = 'move'">Move</button>
    <button onclick="canEdit = 1; canvas.style.cursor = 'auto'">Edit</button>
    <button onclick="zoom(1)">Zoom In</button>
    <button onclick="zoom(0)">Zoom Out</button>
    <button onclick="preview()">Preview</button>
    <button onclick="download()"><a href="" download="" id="download">Download</a></button>
    <button onclick="perspective = 1; tileSize.h = tileSize.w; origin = {x:canvas.width/tileSize.w/2,y:canvas.height/tileSize.h/2-worldSize.h/2}; drawWorld()">Top Down</button>
    <button onclick="perspective = 0; tileSize.h = tileSize.w/2; origin = {x:canvas.width/tileSize.w/2,y:canvas.height/tileSize.h/2-worldSize.h/2}; drawWorld()">Isometric</button>
    <button onclick="selected = []; drawWorld()">Deselect</button>
    <button onclick="invertSelect()">Invert</button>
    <button onclick="rotate()">Rotate</button>
</div>
<script>
    let canvas = document.getElementById("game")
    let heightSlider = document.getElementById("height")
    let ctx = canvas.getContext("2d")
    
    //{top:["fillstyle","strokestyle"],sides:["left","right","srokestyle"],height:height}
    let tiles = [
        {top:["#fff","#000"],sides:["#fff","#fff","#000"],height:1},
        {top:["#28cb48","#119f2d"],sides:["#bf8d1d","#d19d28","#a87910"],height:1.2},
        {top:["#64d3fc","#44a6cb"],sides:["#39c6fa","#4ecdfc","#44a6cb"],height:1},
        {top:["#f1cf69","#C4A010"],sides:["#e8c661","#f2d376","#C4A010"],height:1.1},
        {top:["#d0d0d0","#a5a5a5"],sides:["#bebebe","#d8d8d8","#a5a5a5"],height:1.1}
    ]
    
    let worldSize = {w:10,h:10};
    
    let tileSize = {w:80,h:40};
    
    
    let cursor = {x:0,y:0}
    let origin = {x:canvas.width/tileSize.w/2,y:canvas.height/tileSize.h/2-worldSize.h/2};
    let world = [];
    
    let canEdit = 1;
    let diff = 0;
    let highlighted = 0;
    let perspective = 0;
    let selected = [];
    let canSelect = 0;
    let quickSelect = 0;
    
    function generateWorld(){
        for(i=0;i<worldSize.w*worldSize.h;i++){
            //let t = Math.floor(Math.random()*tiles.length)
            let t = 0;
            world.push({type:t,height:tiles[t].height})
        }
    }
    
    function toScreen(x,y,h){
        return {x:origin.x*tileSize.w + (x-y) * tileSize.w/2,y:origin.y*tileSize.h - h + (x+y) * tileSize.h/2}
    }
    
    function drawWorld(){
        highlighted = 0;
        ctx.clearRect(0,0,canvas.width,canvas.height)
        
        for(y=0;y<worldSize.h;y++){
            for(x=0;x<worldSize.w;x++){
                
                let currentTile = world[y*worldSize.w+x]
                let height;
                
                if(perspective == 0){
                    height = currentTile.height*tileSize.w;
                }else{
                    height = 0;
                }
                
                let pos = toScreen(x,y,height)
                
                
                pos.y += tileSize.h
                
                ctx.lineWidth = 1
                ctx.beginPath()
                ctx.strokeStyle = tiles[currentTile.type].sides[2]
                ctx.fillStyle = tiles[currentTile.type].sides[1]
                ctx.moveTo(pos.x+tileSize.w/2,pos.y-tileSize.h/2)
                ctx.lineTo(pos.x+tileSize.w/2,pos.y-tileSize.h/2+height)
                ctx.lineTo(pos.x,pos.y+height)
                ctx.lineTo(pos.x,pos.y)
                
                if (ctx.isPointInPath(cursor.x,cursor.y)) {
                    highlighted = [x,y,currentTile.height];
                }
                
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
                
                ctx.beginPath()
                ctx.fillStyle = tiles[currentTile.type].sides[0]
                ctx.moveTo(pos.x-tileSize.w/2,pos.y-tileSize.h/2)
                ctx.lineTo(pos.x-tileSize.w/2,pos.y-tileSize.h/2+height)
                ctx.lineTo(pos.x,pos.y+height)
                ctx.lineTo(pos.x,pos.y)
                
                if (ctx.isPointInPath(cursor.x,cursor.y)) {
                    highlighted = [x,y,currentTile.height];
                }
                
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
                
                pos.y -= tileSize.h
                ctx.beginPath()
                ctx.fillStyle = tiles[currentTile.type].top[0]
                ctx.strokeStyle = tiles[currentTile.type].top[1]
                ctx.moveTo(pos.x,pos.y)
                ctx.lineTo(pos.x+tileSize.w/2,pos.y+tileSize.h/2)
                ctx.lineTo(pos.x,pos.y+tileSize.h)
                ctx.lineTo(pos.x-tileSize.w/2,pos.y+tileSize.h/2)
                
                if (ctx.isPointInPath(cursor.x,cursor.y)) {
                    highlighted = [x,y,currentTile.height];
                }
                
                ctx.closePath()
                ctx.fill()
                ctx.stroke()
            }
        }
        
        if(highlighted && canEdit){
            let pos;
                
            if(perspective == 0){
                pos = toScreen(highlighted[0],highlighted[1],highlighted[2]*tileSize.w);
            }else{
                pos = toScreen(highlighted[0],highlighted[1],0);
            }
            
            ctx.beginPath()
            ctx.lineWidth = 2
            ctx.strokeStyle = "#ffeb00"
            ctx.moveTo(pos.x,pos.y)
            ctx.lineTo(pos.x+tileSize.w/2,pos.y+tileSize.h/2)
            ctx.lineTo(pos.x,pos.y+tileSize.h)
            ctx.lineTo(pos.x-tileSize.w/2,pos.y+tileSize.h/2)
            ctx.closePath()
            ctx.stroke()
        }
        
        if(selected.length > 0){
            for(i = 0; i < selected.length; i++){
                let pos;
                
                if(perspective == 0){
                    pos = toScreen(selected[i][0],selected[i][1],selected[i][2]*tileSize.w);
                }else{
                    pos = toScreen(selected[i][0],selected[i][1],0);
                }
            
                ctx.beginPath()
                ctx.lineWidth = 2
                ctx.strokeStyle = "red"
                ctx.moveTo(pos.x,pos.y)
                ctx.lineTo(pos.x+tileSize.w/2,pos.y+tileSize.h/2)
                ctx.lineTo(pos.x,pos.y+tileSize.h)
                ctx.lineTo(pos.x-tileSize.w/2,pos.y+tileSize.h/2)
                ctx.closePath()
                ctx.stroke()
            }
        }
        
    }
    
    
    canvas.onmousemove = function(e){
        cursor.x = e.clientX-canvas.getBoundingClientRect().left;
        cursor.y = e.clientY-canvas.getBoundingClientRect().top;
        
        if(diff && !canEdit){
            origin = {x:cursor.x/tileSize.w-diff.x,y:cursor.y/tileSize.h-diff.y}
        }
        
        if(canEdit && highlighted && canSelect && quickSelect){
            for(i=0;i<selected.length;i++){
                if(highlighted[0] == selected[i][0] && highlighted[1] == selected[i][1]){
                    if(quickSelect == 2){
                        selected.splice(i,1)
                    }
                    
                     break;
                }
                
                if(i == selected.length-1){
                    selected.push(highlighted);
                    heightSlider.value = highlighted[2]*10
                }
            }
        }
        
        drawWorld()    
    }
    
    canvas.onmousedown = function(){
        diff = {x:cursor.x/tileSize.w-origin.x,y:cursor.y/tileSize.h-origin.y};
        canSelect = 1;
        drawWorld()
        
        if(canEdit && highlighted){
            if(selected.length == 0){
                selected.push(highlighted);
                heightSlider.value = highlighted[2]*10
            }else{
                for(i=0;i<selected.length;i++){
                    if(highlighted[0] == selected[i][0] && highlighted[1] == selected[i][1]){
                        selected.splice(i,1)
                        break;
                    }
                
                    if(i == selected.length-1){
                        selected.push(highlighted);
                        heightSlider.value = highlighted[2]*10
                        break;
                    }
                }
            }
        }else if(canEdit && highlighted == 0){
            selected = []
        }
        
        drawWorld()
    }
    
    canvas.onmouseup = function(){
        diff = 0;
        canSelect = 0;
    }
    
    document.onkeydown = (e) => {
        if(e.which == 187){
            zoom(1)
        }
        
        if(e.which == 189 && tileSize.w > 30){
            zoom(0)
        }
        
        if(e.which == 16 && canSelect){
            quickSelect = 1;
        }
        
        if(e.which == 16){
            quickSelect = 1;
        }
        
        if(e.which == 18){
            quickSelect = 2;
        }
        
        if(e.which == 82){
            rotate()
        }
        
        console.log(e.which)
    }
    
    document.onkeyup = (e) => {
        if(e.which == 16 || e.which == 18){
            quickSelect = 0;
        }
        
    }
    
    //window.onresize = function(){
        canvas.width = window.innerWidth*0.8
        canvas.height = window.innerHeight
        origin = {x:canvas.width/tileSize.w/2,y:canvas.height/tileSize.h/2-worldSize.h/2};
        generateWorld()
        drawWorld()
    //}
    
    
    
   // onresize()
    
    function switchTile(type){
        for(let i=0;i<selected.length;i++){
            world[selected[i][1]*worldSize.w+selected[i][0]].type = type
            drawWorld()
        }
    }
    
    function changeHeight(){
        for(let i=0;i<selected.length;i++){
            world[selected[i][1]*worldSize.w+selected[i][0]].height = parseInt(document.getElementById("height").value)/10
            selected[i][2] = world[selected[i][1]*worldSize.w+selected[i][0]].height
            drawWorld()
        }
    }
    
    function preview(){
        selected = []
        canEdit = 0;
        
        drawWorld()
        
        var win = window.open();
        win.document.write('<iframe src="' + canvas.toDataURL()  + '" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen><a href="'+ canvas.toDataURL() +'" download="'+ 'name' + '">Download</a></iframe>');
        
        canEdit = 1;
    }
    
    function download(){
        selected = []
        canEdit = 0;
        
        drawWorld()
        
        document.getElementById("download").setAttribute("download", "name")
        document.getElementById("download").setAttribute("href", canvas.toDataURL())
        
        canEdit = 1;
    }
    
    function invertSelect(){
        let newSelected = [];
        
        for(let y=0;y<worldSize.h;y++){
            for(let x=0;x<worldSize.w;x++){
                let isSelected = 0;
                for(let i=0;i<selected.length;i++){
                    if(selected[i][0] == x && selected[i][1] == y){
                        isSelected = 1;
                        break;
                    }
                }
                if(!isSelected){
                    newSelected.push([x,y,world[y*worldSize.w+x].height])
                }
            }
        }
        selected = newSelected;
        drawWorld()
    }
    
    function switchPerspective(){
        
    }
    
    function zoom(z){
        if(z){
            let tempOrigin = {x:origin.x*tileSize.w,y:origin.y*tileSize.h}
            tileSize.w *= 1.02;
            if(perspective){
                tileSize.h = tileSize.w
            }else{
                tileSize.h = tileSize.w/2
            }
            origin.x = tempOrigin.x/tileSize.w
            origin.y = tempOrigin.y/tileSize.h
            drawWorld()
        }else{
            let tempOrigin = {x:origin.x*tileSize.w,y:origin.y*tileSize.h}
            tileSize.w *= 0.98;
            if(perspective){
                tileSize.h = tileSize.w
            }else{
                tileSize.h = tileSize.w/2
            }
            origin.x = tempOrigin.x/tileSize.w
            origin.y = tempOrigin.y/tileSize.h
            drawWorld()
        }
    }
    
    function rotate(){
        let tempArr = [];
        
        for(let y=0;y<worldSize.h;y++){
            tempArr.push([])
            for(let x=0;x<worldSize.w;x++){
                tempArr[y].push(world[y*worldSize.w+x])
            }
        }
        
        size = tempArr.length;
        layer_count = Math.floor(size/2)
        
        for(let i=0; i < layer_count; i++){
            let first = i;
            let last = size - first - 1;
            
            for(let e=first; e<last; e++){
                offset = e - first;
                
                let corners = [
                    tempArr[first][e], //back
                    tempArr[e][last], //right
                    tempArr[last][last-offset], //front
                    tempArr[last-offset][first] //left
                ]
                
                tempArr[first][e] = corners[3]
                tempArr[e][last] = corners[0]
                tempArr[last][last-offset] = corners[1]
                tempArr[last-offset][first] = corners[2]
            }
        }
        
        world = []
        
        for(let x = 0; x < tempArr.length; x++){
            for(let y =0; y < tempArr[x].length;y++){
                world.push(tempArr[x][y])
            }
        }
        selected = []
        drawWorld()
    }
    
    canvas.onmousewheel = (e) => {
        if(e.wheelDelta > 0 && tileSize.w > 20){
            zoom(0)
        }
        
        if(e.wheelDelta < 0 && tileSize.w < 960){
            zoom(1)
        }
        
        e.preventDefault()
    }
    
</script>
    
</html>
